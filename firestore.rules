rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // === UTILITY FUNCTIONS ===
    function isUserAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isUserAuthenticated() && request.auth.uid == userId;
    }

    function getConversationData(conversationId) {
      return get(/databases/$(database)/documents/conversations/$(conversationId)).data;
    }
    
    function isConversationParticipant(conversationId) {
      return isUserAuthenticated() && request.auth.uid in getConversationData(conversationId).participantIds;
    }

    // === VALIDATION FUNCTIONS ===
    function validateUserData(data) {
      return data.keys().hasAll(['uid', 'email', 'displayName', 'createdAt', 'isVerified']) &&
             data.uid == request.auth.uid &&
             data.email is string &&
             data.displayName is string &&
             data.displayName.size() > 0;
    }
    
    function validateConversationCreation(data) {
      return data.keys().hasAll(['participants', 'participantIds', 'createdAt', 'updatedAt', 'type', 'lastMessage', 'unreadCounts']) &&
             data.participants is list &&
             data.participantIds is list &&
             data.participants.size() == 2 &&
             data.participants.size() == data.participantIds.size() &&
             data.type == 'direct' &&
             data.lastMessage == null &&
             data.unreadCounts is map &&
             data.unreadCounts.keys().hasAll(data.participantIds) &&
             data.unreadCounts[data.participantIds[0]] == 0 &&
             data.unreadCounts[data.participantIds[1]] == 0;
    }
    
    function validateMessageCreation(data) {
      return data.keys().hasAll(['content', 'senderId', 'timestamp', 'type', 'readBy']) &&
             data.content is string &&
             data.senderId == request.auth.uid &&
             data.type == 'text' && // Only allow text messages
             data.readBy is list &&
             data.readBy.size() == 1 &&
             data.readBy[0] == request.auth.uid &&
             data.content.size() > 0;
    }

    // === MAIN RULES ===

    match /users/{userId} {
      allow read: if isUserAuthenticated();
      allow write: if isOwner(userId) && validateUserData(request.resource.data);
    }
    
    match /conversations/{conversationId} {
      allow get: if isUserAuthenticated();
      allow list, read: if isConversationParticipant(conversationId);
      
      allow create: if isUserAuthenticated() && 
                        request.auth.uid in request.resource.data.participantIds &&
                        validateConversationCreation(request.resource.data);
      
      allow update: if isConversationParticipant(conversationId) &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'updatedAt', 'unreadCounts']);
    }
    
    match /conversations/{conversationId}/messages/{messageId} {
      allow list, read: if isConversationParticipant(conversationId);

      allow create: if isConversationParticipant(conversationId) &&
                       validateMessageCreation(request.resource.data);
      
      allow update: if isConversationParticipant(conversationId) &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']) &&
                       request.resource.data.readBy == resource.data.readBy.concat([request.auth.uid]);
    }
  }
}

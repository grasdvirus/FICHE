rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // === UTILITY FUNCTIONS ===
    function getConversationParticipants(conversationId) {
      return get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }
    
    function isCommunityMember(communityId, userId) {
      return exists(/databases/$(database)/documents/communities/$(communityId)/members/$(userId));
    }
    
    function isCommunityAdmin(communityId, userId) {
      let community = get(/databases/$(database)/documents/communities/$(communityId)).data;
      let member = get(/databases/$(database)/documents/communities/$(communityId)/members/$(userId)).data;
      return userId == community.creatorId || 
             (community.keys().hasAny(['admins']) && userId in community.admins) || 
             (member.keys().hasAny(['role']) && member.role in ['admin', 'moderator']);
    }

    function isConversationModerator(conversationId, userId) {
      let conversation = get(/databases/$(database)/documents/conversations/$(conversationId)).data;
      return (conversation.keys().hasAny(['moderators']) && userId in conversation.moderators);
    }

    function isVerifiedUser(userId) {
      return request.auth.token.email_verified == true;
    }

    // === VALIDATION FUNCTIONS ===
    function validateUserDataOnCreate(data) {
      // Checks that only the allowed fields are present and correctly typed
      return data.keys().hasOnly(['uid', 'displayName', 'email', 'photoURL', 'createdAt', 'isVerified', 'visibility']) &&
             data.uid == request.auth.uid &&
             data.displayName is string && data.displayName.size() > 0 &&
             (data.email is string || data.email == null) &&
             (data.photoURL is string || data.photoURL == null) &&
             data.isVerified is bool &&
             data.visibility == 'public';
    }

    function validateUserDataOnUpdate(data) {
      // On update, a user cannot change their UID or when their account was created.
      return data.keys().hasOnly(['uid', 'displayName', 'email', 'photoURL', 'createdAt', 'isVerified', 'visibility']) &&
             data.uid == request.auth.uid &&
             data.displayName is string && data.displayName.size() > 0 &&
             (data.email is string || data.email == null) &&
             (data.photoURL is string || data.photoURL == null) &&
             data.createdAt == resource.data.createdAt && // Enforce immutability of createdAt
             data.isVerified is bool &&
             data.visibility == 'public';
    }
    
    function validateDocumentData(data) {
      return data.keys().hasAll(['title', 'content', 'authorId', 'createdAt', 'visibility']) &&
             data.title is string &&
             data.content is string &&
             data.authorId is string &&
             data.visibility in ['public', 'private', 'shared'] &&
             data.title.size() >= 1 &&
             data.title.size() <= 200 &&
             data.content.size() <= 50000;
    }
    
    function validateDocumentUpdate(newData, oldData) {
      return newData.authorId == oldData.authorId &&
             newData.createdAt == oldData.createdAt &&
             validateDocumentData(newData);
    }
    
    function validateConversationData(data) {
      return data.keys().hasAll(['participantIds', 'createdAt', 'updatedAt', 'type', 'lastMessage', 'unreadCounts']) &&
             data.participantIds is list &&
             data.participantIds.size() >= 2 &&
             data.type in ['direct', 'group'] &&
             data.lastMessage == null &&
             data.unreadCounts is map &&
             data.unreadCounts.keys().hasAll(data.participantIds);
    }
    
    function validateConversationUpdate(newData, oldData) {
      let changedKeys = newData.diff(oldData).affectedKeys();
      return newData.createdAt == oldData.createdAt &&
             newData.type == oldData.type &&
             newData.participantIds == oldData.participantIds &&
             changedKeys.hasOnly(['lastMessage', 'updatedAt', 'unreadCounts']);
    }
    
    function validateMessageData(data) {
      return data.keys().hasAll(['content', 'senderId', 'timestamp', 'type', 'readBy']) &&
             data.content is string &&
             data.senderId is string &&
             data.type in ['text'] && // RESTRICTION: Only text messages are allowed
             data.content.size() >= 1 &&
             data.content.size() <= 5000 &&
             data.readBy is list &&
             data.readBy.size() == 1 &&
             data.readBy[0] == data.senderId; // Marked as read by sender on creation
    }
    
    function validateMessageUpdate(newData, oldData) {
      return newData.senderId == oldData.senderId &&
             newData.timestamp == oldData.timestamp &&
             newData.type == oldData.type &&
             newData.keys().hasAll(['content', 'edited']) &&
             newData.edited == true;
    }
    
    function validateCommunityData(data) {
      return data.keys().hasAll(['name', 'description', 'creatorId', 'createdAt', 'visibility', 'imageUrl', 'memberCount']) &&
             data.name is string && data.name.size() > 0 &&
             data.description is string && data.description.size() > 0 &&
             data.creatorId == request.auth.uid &&
             data.visibility == 'public' &&
             data.imageUrl is string &&
             data.memberCount == 1;
    }
    
    function validateCommunityUpdate(newData, oldData) {
      return newData.creatorId == oldData.creatorId &&
             newData.createdAt == oldData.createdAt &&
             newData.imageUrl == oldData.imageUrl;
    }
    
    function validateMembershipData(data) {
      return data.keys().hasAll(['joinedAt', 'role']) &&
             data.role in ['member', 'moderator', 'admin'];
    }
    
    function validateMembershipUpdate(newData, oldData) {
      return newData.joinedAt == oldData.joinedAt &&
             newData.role in ['member', 'moderator', 'admin'];
    }
    
    function validateAISuggestionData(data) {
      return data.keys().hasAll(['originalText', 'suggestions', 'timestamp', 'userId']) &&
             data.originalText is string &&
             data.suggestions is list &&
             data.userId == request.auth.uid &&
             data.originalText.size() <= 10000;
    }

    // === MAIN RULES ===

    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == userId && validateUserDataOnCreate(request.resource.data);
      allow update: if request.auth != null && request.auth.uid == userId && validateUserDataOnUpdate(request.resource.data);
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    match /documents/{docId} {
      allow read: if request.auth != null && 
                      (resource.data.visibility == 'public' ||
                       request.auth.uid == resource.data.authorId ||
                       (resource.data.keys().hasAny(['sharedWith']) && request.auth.uid in resource.data.sharedWith) ||
                       (resource.data.keys().hasAny(['collaborators']) && request.auth.uid in resource.data.collaborators));

      allow create: if request.auth != null && 
                        request.auth.uid == request.resource.data.authorId &&
                        validateDocumentData(request.resource.data);

      allow update: if request.auth != null && 
                        (request.auth.uid == resource.data.authorId ||
                         (resource.data.keys().hasAny(['collaborators']) && request.auth.uid in resource.data.collaborators)) &&
                        validateDocumentUpdate(request.resource.data, resource.data);

      allow delete: if request.auth != null && 
                        request.auth.uid == resource.data.authorId;
    }
    
    match /conversations/{conversationId} {
      allow get: if request.auth != null && 
                    (request.auth.uid in conversationId.split('_'));

      allow read: if request.auth != null && 
                      request.auth.uid in resource.data.participantIds;
      
      allow create: if request.auth != null && 
                        request.auth.uid in request.resource.data.participantIds &&
                        validateConversationData(request.resource.data) &&
                        (request.resource.data.type == 'direct' || isVerifiedUser(request.auth.uid));
      
      allow update: if request.auth != null && 
                        request.auth.uid in resource.data.participantIds &&
                        validateConversationUpdate(request.resource.data, resource.data);
      
      allow delete: if request.auth != null && 
                       request.auth.uid in resource.data.participantIds;
    }
    
    match /conversations/{conversationId}/messages/{messageId} {
      allow read: if request.auth != null && 
                      request.auth.uid in getConversationParticipants(conversationId);
      
      allow create: if request.auth != null && 
                        request.auth.uid == request.resource.data.senderId &&
                        request.auth.uid in getConversationParticipants(conversationId) &&
                        validateMessageData(request.resource.data);
      
      allow update: if request.auth != null &&
                      (
                        (request.auth.uid == resource.data.senderId &&
                         request.time < resource.data.timestamp + duration.value(5, 'm') &&
                         validateMessageUpdate(request.resource.data, resource.data))
                        ||
                        (request.auth.uid in getConversationParticipants(conversationId) &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']) &&
                         request.resource.data.readBy.size() == resource.data.readBy.size() + 1 &&
                         request.auth.uid in request.resource.data.readBy)
                      );
      
      allow delete: if request.auth != null && 
                        request.auth.uid in getConversationParticipants(conversationId);
    }
    
    match /communities/{communityId} {
      allow read: if request.auth != null;
      
      allow create: if request.auth != null && 
                        request.auth.uid == request.resource.data.creatorId &&
                        validateCommunityData(request.resource.data);
      
      allow update: if request.auth != null && 
                        request.auth.uid == resource.data.creatorId &&
                        validateCommunityUpdate(request.resource.data, resource.data);
      
      allow delete: if request.auth != null && 
                        request.auth.uid == resource.data.creatorId;
    }
    
    match /communities/{communityId}/members/{userId} {
      allow read: if request.auth != null && 
                      isCommunityMember(communityId, request.auth.uid);
      
      allow create: if request.auth != null && 
                        request.auth.uid == userId &&
                        validateMembershipData(request.resource.data) &&
                        (get(/databases/$(database)/documents/communities/$(communityId)).data.visibility == 'public' || isCommunityAdmin(communityId, request.auth.uid));
      
      allow delete: if request.auth != null && 
                        (request.auth.uid == userId ||
                         isCommunityAdmin(communityId, request.auth.uid));
      
      allow update: if request.auth != null && 
                        isCommunityAdmin(communityId, request.auth.uid) &&
                        validateMembershipUpdate(request.resource.data, resource.data);
    }
    
    match /ai-suggestions/{userId} {
      allow read, write: if request.auth != null && 
                             request.auth.uid == userId &&
                             validateAISuggestionData(request.resource.data);
    }
    
    match /analytics/{userId} {
      allow read, write: if request.auth != null && 
                             request.auth.uid == userId;
    }
  }
}

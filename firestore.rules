rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // === RÈGLES POUR LES UTILISATEURS ===
    match /users/{userId} {
      // Un utilisateur peut lire et écrire ses propres données
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Permet la lecture des profils publics pour les recherches
      allow list: if request.auth != null;
    }
    
    // === RÈGLES POUR LES DOCUMENTS/TEXTES ===
    match /documents/{docId} {
      // L'auteur peut tout faire sur ses documents
      allow read, write, delete: if request.auth != null && 
                                    request.auth.uid == resource.data.authorId;
      
      // Lecture des documents partagés
      allow read: if request.auth != null && 
                     (request.auth.uid in resource.data.sharedWith ||
                      resource.data.visibility == 'public');
      
      // Création de nouveaux documents
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.authorId &&
                       validateDocumentData(request.resource.data);
      
      // Modification par les collaborateurs
      allow update: if request.auth != null && 
                       (request.auth.uid == resource.data.authorId ||
                        request.auth.uid in resource.data.collaborators) &&
                       validateDocumentUpdate(request.resource.data, resource.data);
    }
    
    // === RÈGLES POUR LES CONVERSATIONS ===
    match /conversations/{conversationId} {
      // Les participants peuvent lire la conversation et vérifier son existence
      allow get, list, read: if request.auth != null && 
                     request.auth.uid in resource.data.participantIds;
      
      // Création de nouvelles conversations
      allow create: if request.auth != null && 
                       request.auth.uid in request.resource.data.participantIds;
      
      // Mise à jour des métadonnées de conversation (dernier message)
      allow update: if request.auth != null && 
                       request.auth.uid in resource.data.participantIds;
      
      // Suppression uniquement par l'administrateur
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.adminId;

        // === RÈGLES POUR LES MESSAGES ===
        match /messages/{messageId} {
            // Les participants peuvent lire les messages
            allow read, list: if request.auth != null && 
                            request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
            
            // Création de nouveaux messages
            allow create: if request.auth != null && 
                            request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds &&
                            request.auth.uid == request.resource.data.senderId;
            
            // L'expéditeur peut modifier ses propres messages (dans les 5 minutes)
            allow update: if request.auth != null && 
                            request.auth.uid == resource.data.senderId &&
                            request.time < resource.data.timestamp + duration.value(5, 'm');
            
            // L'expéditeur peut supprimer ses propres messages
            allow delete: if request.auth != null && 
                            request.auth.uid == resource.data.senderId;
        }
    }
    
    
    // === RÈGLES POUR LES COMMUNAUTÉS ===
    match /communities/{communityId} {
      // Lecture publique des communautés
      allow read: if request.auth != null;
      
      // Création de nouvelles communautés
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.creatorId &&
                       validateCommunityData(request.resource.data);
      
      // Mise à jour par les administrateurs
      allow update: if request.auth != null && 
                       (request.auth.uid == resource.data.creatorId ||
                        request.auth.uid in resource.data.admins) &&
                       validateCommunityUpdate(request.resource.data, resource.data);
      
      // Suppression par le créateur uniquement
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.creatorId;

        // === RÈGLES POUR LES MEMBRES DES COMMUNAUTÉS ===
        match /members/{userId} {
        // Les membres peuvent lire la liste des membres
        allow read: if request.auth != null && 
                        isCommunityMember(communityId, request.auth.uid);
        
        // Rejoindre une communauté
        allow create: if request.auth != null && 
                        request.auth.uid == userId &&
                        validateMembershipData(request.resource.data);
        
        // Quitter une communauté
        allow delete: if request.auth != null && 
                        (request.auth.uid == userId ||
                        isCommunityAdmin(communityId, request.auth.uid));
        
        // Mise à jour des rôles par les admins
        allow update: if request.auth != null && 
                        isCommunityAdmin(communityId, request.auth.uid) &&
                        validateMembershipUpdate(request.resource.data, resource.data);
        }
    }
    
    
    // === RÈGLES POUR LES SUGGESTIONS IA ===
    match /ai-suggestions/{userId} {
      // Un utilisateur peut accéder à ses propres suggestions
      allow read, write: if request.auth != null && 
                            request.auth.uid == userId &&
                            validateAISuggestionData(request.resource.data);
    }
    
    // === RÈGLES POUR LES ANALYTICS ===
    match /analytics/{userId} {
      // Lecture et écriture des données d'analytics de l'utilisateur
      allow read, write: if request.auth != null && 
                            request.auth.uid == userId;
    }
    
    // === FONCTIONS DE VALIDATION ===
    function validateUserData(data) {
      return data.keys().hasAll(['uid', 'displayName', 'email']) &&
             data.email is string &&
             data.displayName is string &&
             data.email.matches('.*@.*\\..*') &&
             data.displayName.size() >= 2 &&
             data.displayName.size() <= 50;
    }
    
    function validateDocumentData(data) {
      return data.keys().hasAll(['title', 'content', 'authorId', 'createdAt']) &&
             data.title is string &&
             data.content is string &&
             data.authorId is string &&
             data.title.size() >= 1 &&
             data.title.size() <= 200 &&
             data.content.size() <= 50000;
    }
    
    function validateDocumentUpdate(newData, oldData) {
      return newData.authorId == oldData.authorId &&
             newData.createdAt == oldData.createdAt &&
             validateDocumentData(newData);
    }
    
    function validateConversationData(data) {
      return data.keys().hasAll(['participantIds', 'updatedAt']) &&
             data.participantIds is list &&
             data.participantIds.size() >= 2 &&
             data.participantIds.size() <= 100;
    }
    
    function validateConversationUpdate(newData, oldData) {
      return newData.participantIds == oldData.participantIds;
    }
    
    function validateMessageData(data) {
      return data.keys().hasAll(['content', 'senderId', 'timestamp', 'readBy']) &&
             data.content is string &&
             data.senderId is string &&
             data.readBy is list &&
             data.content.size() >= 1 &&
             data.content.size() <= 5000;
    }
    
    function validateMessageUpdate(newData, oldData) {
      return newData.senderId == oldData.senderId &&
             newData.timestamp == oldData.timestamp &&
             newData.keys().hasAll(['content', 'edited']) &&
             newData.edited == true;
    }
    
    function validateCommunityData(data) {
      return data.keys().hasAll(['name', 'description', 'creatorId', 'createdAt']) &&
             data.name is string &&
             data.description is string &&
             data.creatorId is string &&
             data.name.size() >= 3 &&
             data.name.size() <= 100 &&
             data.description.size() <= 500;
    }
    
    function validateCommunityUpdate(newData, oldData) {
      return newData.creatorId == oldData.creatorId &&
             newData.createdAt == oldData.createdAt;
    }
    
    function validateMembershipData(data) {
      return data.keys().hasAll(['joinedAt', 'role']) &&
             data.role in ['member', 'moderator', 'admin'];
    }
    
    function validateMembershipUpdate(newData, oldData) {
      return newData.joinedAt == oldData.joinedAt &&
             newData.role in ['member', 'moderator', 'admin'];
    }
    
    function validateAISuggestionData(data) {
      return data.keys().hasAll(['originalText', 'suggestions', 'timestamp']) &&
             data.originalText is string &&
             data.suggestions is list &&
             data.originalText.size() <= 10000;
    }
    
    // === FONCTIONS UTILITAIRES ===
    function isCommunityMember(communityId, userId) {
      return exists(/databases/$(database)/documents/communities/$(communityId)/members/$(userId));
    }
    
    function isCommunityAdmin(communityId, userId) {
      let community = get(/databases/$(database)/documents/communities/$(communityId)).data;
      let member = get(/databases/$(database)/documents/communities/$(communityId)/members/$(userId)).data;
      return userId == community.creatorId || 
             userId in community.admins || 
             member.role in ['admin', 'moderator'];
    }
  }
}

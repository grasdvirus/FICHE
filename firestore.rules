rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // === FONCTIONS UTILITAIRES ===
    function getConversationParticipants(conversationId) {
      // Lit les participants d'une conversation en utilisant le champ indexé
      return get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }
    
    function isCommunityMember(communityId, userId) {
      return exists(/databases/$(database)/documents/communities/$(communityId)/members/$(userId));
    }
    
    function isCommunityAdmin(communityId, userId) {
      let community = get(/databases/$(database)/documents/communities/$(communityId)).data;
      let member = get(/databases/$(database)/documents/communities/$(communityId)/members/$(userId)).data;
      return userId == community.creatorId || 
             (community.keys().hasAny(['admins']) && userId in community.admins) || 
             (member.keys().hasAny(['role']) && member.role in ['admin', 'moderator']);
    }

    // === FONCTIONS DE VALIDATION ===
    function validateUserData(data) {
      return data.keys().hasAll(['uid', 'email', 'displayName', 'createdAt']) &&
             data.email is string &&
             data.displayName is string &&
             data.email.matches('.*@.*\\..*') &&
             data.displayName.size() >= 2 &&
             data.displayName.size() <= 50;
    }
    
    function validateDocumentData(data) {
      return data.keys().hasAll(['title', 'content', 'authorId', 'createdAt']) &&
             data.title is string &&
             data.content is string &&
             data.authorId is string &&
             data.title.size() >= 1 &&
             data.title.size() <= 200 &&
             data.content.size() <= 50000;
    }
    
    function validateDocumentUpdate(newData, oldData) {
      return newData.authorId == oldData.authorId &&
             newData.createdAt == oldData.createdAt &&
             validateDocumentData(newData);
    }
    
    function validateConversationData(data) {
      // Vérifie tous les champs requis pour une nouvelle conversation.
      return data.keys().hasAll(['participants', 'participantIds', 'createdAt', 'updatedAt', 'type', 'lastMessage']) &&
             data.participants is list &&
             data.participantIds is list &&
             data.participants.size() >= 2 &&
             data.participants.size() == data.participantIds.size() &&
             data.type == 'direct' && // L'application ne gère que le 'direct' pour le moment
             data.lastMessage == null;
    }
    
    function validateConversationUpdate(newData, oldData) {
      // Valide les mises à jour d'une conversation (ex: nouveau message).
      return newData.createdAt == oldData.createdAt &&
             newData.type == oldData.type &&
             newData.participants.size() == oldData.participants.size() && 
             newData.participantIds.size() == oldData.participantIds.size();
    }
    
    function validateMessageData(data) {
      return data.keys().hasAll(['content', 'senderId', 'timestamp', 'type']) &&
             data.content is string &&
             data.senderId is string &&
             data.type in ['text', 'image', 'file', 'ai-suggestion'] &&
             data.content.size() >= 1 &&
             data.content.size() <= 5000;
    }
    
    function validateMessageUpdate(newData, oldData) {
      return newData.senderId == oldData.senderId &&
             newData.timestamp == oldData.timestamp &&
             newData.type == oldData.type &&
             newData.keys().hasAll(['content', 'edited']) &&
             newData.edited == true;
    }
    
    function validateCommunityData(data) {
      return data.keys().hasAll(['name', 'description', 'creatorId', 'createdAt']) &&
             data.name is string &&
             data.description is string &&
             data.creatorId is string &&
             data.name.size() >= 3 &&
             data.name.size() <= 100 &&
             data.description.size() <= 500;
    }
    
    function validateCommunityUpdate(newData, oldData) {
      return newData.creatorId == oldData.creatorId &&
             newData.createdAt == oldData.createdAt;
    }
    
    function validateMembershipData(data) {
      return data.keys().hasAll(['joinedAt', 'role']) &&
             data.role in ['member', 'moderator', 'admin'];
    }
    
    function validateMembershipUpdate(newData, oldData) {
      return newData.joinedAt == oldData.joinedAt &&
             newData.role in ['member', 'moderator', 'admin'];
    }
    
    function validateAISuggestionData(data) {
      return data.keys().hasAll(['originalText', 'suggestions', 'timestamp']) &&
             data.originalText is string &&
             data.suggestions is list &&
             data.originalText.size() <= 10000;
    }

    // === RÈGLES PRINCIPALES ===

    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    match /documents/{docId} {
      allow read, write, delete: if request.auth != null && 
                                    request.auth.uid == resource.data.authorId;
      allow read: if request.auth != null && 
                     (request.auth.uid in resource.data.sharedWith ||
                      resource.data.visibility == 'public');
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.authorId &&
                       validateDocumentData(request.resource.data);
      allow update: if request.auth != null && 
                       (request.auth.uid == resource.data.authorId ||
                        request.auth.uid in resource.data.collaborators) &&
                       validateDocumentUpdate(request.resource.data, resource.data);
    }
    
    match /conversations/{conversationId} {
      // List/Get: Les participants peuvent lire les conversations dont ils font partie.
      // Cette règle fonctionne avec la requête du client sur 'participantIds'.
      allow read: if request.auth != null && 
                     request.auth.uid in resource.data.participantIds;
      
      // Create: Les utilisateurs authentifiés peuvent créer des conversations dont ils font partie.
      allow create: if request.auth != null && 
                       request.auth.uid in request.resource.data.participants &&
                       validateConversationData(request.resource.data);
      
      // Update: Les participants peuvent mettre à jour les conversations (ex: lorsqu'un nouveau message est envoyé).
      allow update: if request.auth != null && 
                       request.auth.uid in resource.data.participantIds &&
                       validateConversationUpdate(request.resource.data, resource.data);
      
      // Delete: Uniquement un admin peut supprimer (non implémenté dans l'app).
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.adminId;
    }
    
    match /conversations/{conversationId}/messages/{messageId} {
      // Read: Les participants à la conversation peuvent lire les messages.
      allow read: if request.auth != null && 
                     request.auth.uid in getConversationParticipants(conversationId);
      
      // Create: Un participant peut créer un message et doit en être l'expéditeur.
      allow create: if request.auth != null && 
                       request.auth.uid in getConversationParticipants(conversationId) &&
                       request.auth.uid == request.resource.data.senderId &&
                       validateMessageData(request.resource.data);
      
      // Update: L'expéditeur peut modifier son propre message dans les 5 minutes.
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.senderId &&
                       request.time < resource.data.timestamp + duration.value(5, 'm') &&
                       validateMessageUpdate(request.resource.data, resource.data);
      
      // Delete: L'expéditeur peut supprimer son propre message.
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.senderId;
    }
    
    match /communities/{communityId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.creatorId &&
                       validateCommunityData(request.resource.data);
      allow update: if request.auth != null && 
                       (request.auth.uid == resource.data.creatorId ||
                        isCommunityAdmin(communityId, request.auth.uid)) &&
                       validateCommunityUpdate(request.resource.data, resource.data);
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.creatorId;
    }
    
    match /communities/{communityId}/members/{userId} {
      allow read: if request.auth != null && 
                     isCommunityMember(communityId, request.auth.uid);
      allow create: if request.auth != null && 
                       request.auth.uid == userId &&
                       validateMembershipData(request.resource.data);
      allow delete: if request.auth != null && 
                       (request.auth.uid == userId ||
                        isCommunityAdmin(communityId, request.auth.uid));
      allow update: if request.auth != null && 
                       isCommunityAdmin(communityId, request.auth.uid) &&
                       validateMembershipUpdate(request.resource.data, resource.data);
    }
    
    match /ai-suggestions/{userId} {
      allow read, write: if request.auth != null && 
                            request.auth.uid == userId &&
                            validateAISuggestionData(request.resource.data);
    }
    
    match /analytics/{userId} {
      allow read, write: if request.auth != null && 
                            request.auth.uid == userId;
    }
  }
}
